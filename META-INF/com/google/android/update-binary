#!/sbin/sh
# My Charging Controller
# mcc Install (201804191)
# JayminSuthar @ xda-developers

# Copyright (c) 2018 Jaymin Suthar. All rights reserved.

# This file is a part of "My Charging Controller (mcc)".

# mcc is released under the terms of the GNU GPL v3, as been
## published by the Free Software Foundation. And permission
## hereby is granted to use, modify or redistribute it maybe
## partially or entirely under GPLv3 only.

# mcc was written in a hope of being useful. And any kind of
## WARRANTY is NOT provided. And I can't be held responsible
## for anything caused by it.

# You should already have received a copy of GPLv3 with mcc,
## if not, see <http://www.gnu.org/licenses/>.

if test ! $BOOTMODE; then
    exit 1;
elif ! util_funcs=$(ls /data/adb/magisk/util_functions.sh || ls /data/magisk/util_functions.sh); then
    exit 1;
elif test ! $(sed -n 's/^MAGISK_VER_CODE=//p' $util_funcs) -ge 1400; then
    exit 1;
fi;
set -x; echo -e '\n';
zip_file="$3";
tmp_dir=/dev/mcc_tmp;
tmp_file=$tmp_dir/tmp_f;
merge_root=$tmp_dir/img;
mod_dir=$merge_root/mcc;
sys_dir=$mod_dir/system;
image=${util_funcs%/*/*}/magisk_merge.img;
mount_point=$(find /sbin/.core/img /magisk -type d -maxdepth 0);
main_mod_dir=$mount_point/mcc;
abort() { echo -e "mcc: error: $1\n"; exit 1; }
printp() { echo -e "mcc: info: $1\n"; }
get_prop() { sed -n "s/^$1=//p" $2; }
set_prop() { sed -i "s|^$1=.*|$1=$2|g" $mod_dir/files/secure/mcc.conf; }
is_charging() { grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $uevent; }
get_size() {
    e2fsck -n $image | grep -Eo '[0-9]+/[0-9]+ blocks' | awk -F/ "{ print int((\$$1 + 255) / 256) }";
}
set_perms() {
    find $1 | while read entry; do
        chown 0:$2 $entry;
        chmod $3 $entry; if test -d $entry; then chmod 0755 $entry; fi;
        chcon u:object_r:system_file:s0 $entry;
    done;
}
rm -rf $tmp_dir; mkdir -p $merge_root;
echo -e '-------------------------------------------------------------\n';
echo "                    MC's Charging Controller                      ";
echo -e '-------------------------------------------------------------\n\n\n';
(export no_ver_logs=true; mcc --enable; sleep 3; mcc --clean) >/dev/null &
find /sys/devices /sys/module -type f -name uevent >$tmp_file &
printp 'Checking compatibility (requires charging ON)...';
wait;
if test -f /cache/mcc_noo; then only_system=true; fi;
i=1;
while read uevent; do
    chmod u+r $uevent;
    if grep -q '^POWER_SUPPLY_NAME=.*[Bb]att' $uevent; then
        while read eff_uevent; do
            chmod u+r $eff_uevent;
            if grep -Eq '^POWER_SUPPLY_NAME=.*([Bb]att|USB|usb)' $eff_uevent; then
                proceed=true;
            elif grep -Eq '^DRIVER=.*[Cc]harg(er|ing)' $eff_uevent; then
                proceed=true;
            fi;
            if test $proceed; then
                unset proceed;
                for ref in ${eff_uevent%/*}/*; do
                    if test ! -f $ref; then
                        skip=true;
                    elif ! ls -l $ref | grep -Eq '^\-[rx\-]+w[rwx\-]* '; then
                        skip=true;
                    elif test $only_system && ! ls -l $ref | grep -Eq ' system | radio '; then
                        skip=true;
                    fi;
                    if test ! $skip; then
                        chmod u+r $ref;
                        case "$(cat $ref)" in
                            1       ) c_ON=1;        c_OFF=0;        ;;
                            0       ) c_ON=0;        c_OFF=1;        ;;
                            on      ) c_ON=on;       c_OFF=off;      ;;
                            off     ) c_ON=off;      c_OFF=on;       ;;
                            true    ) c_ON=true;     c_OFF=false;    ;;
                            false   ) c_ON=false;    c_OFF=true;     ;;
                            enable  ) c_ON=enable;   c_OFF=disable;  ;;
                            disable ) c_ON=disable;  c_OFF=enable;   ;;
                            enabled ) c_ON=enabled;  c_OFF=disabled; ;;
                            disabled) c_ON=disabled; c_OFF=enabled;  ;;
                            *       ) continue;                      ;;
                        esac;
                        echo $c_OFF >$ref; sleep 0.6;
                        if ! is_charging; then
                            echo $c_ON >$ref; sleep 0.6;
                            if is_charging; then
                                eval switch_$i=\"$ref $c_ON $c_OFF\"; let i++;
                                if test $i -eq 3; then break 3; fi;
                            fi;
                        fi;
                        echo $c_ON >$ref;
                    fi;
                    unset skip;
                done;
                if test $i -gt 1; then break 2; fi;
            fi;
        done <$tmp_file;
    fi;
done <$tmp_file;
if test $i -eq 1; then abort 'Failed the check'; fi;
printp OK; echo -e '\n';
if test -f $image; then
    printp "$image exists";
    e2fsck -pf $image >&2;
    img_total=$(get_size 2);
    if test $(get_size 1) -eq $img_total; then
        printp "Expanding $image...";
        resize2fs $image $((img_total + 32))M;
    fi;
else
    printp "Creating $image...";
    if ! make_ext4fs -l 64M $image >&2; then
        /system/bin/mke2fs -t ext4 $image 64M >&2;
    fi;
fi;
printp "Mounting $image...";
for minor in 1 2 3 4 5 6 7; do
    loop_device=/dev/block/loop$minor;
    mknod $loop_device b 7 $minor;
    losetup $loop_device $image;
    if mount -t ext4 -o rw,noatime $loop_device $merge_root; then break; fi;
done;
if ! grep -q " $merge_root " /proc/mounts; then
    abort "Failed to mount $image";
fi;
rm -rf $mod_dir;
mkdir -p $mod_dir/docs $main_mod_dir;
printp 'Extracting mcc files...';
unzip -o "$zip_file" 'system/*' 'files/*' post-fs-data.sh service.sh module.prop -d $mod_dir >&2;
unzip -o "$zip_file" COPYING README.md -d $mod_dir/docs >&2;
if test ! -d /system/xbin; then
    mv $sys_dir/xbin $sys_dir/bin;
fi;
set_prop uevent $uevent;
for i in 1 2; do
    switch="$(eval echo \$switch_$i)";
    if test -n "$switch"; then set_prop switch_$i "$switch"; fi;
done;
if test $(get_prop versionCode $main_mod_dir/module.prop || echo 0) -lt 201804171; then
    no_restore=true;
elif ! old_conf=$(ls $main_mod_dir/files/secure/mcc.conf); then
    no_restore=true;
fi;
if test ! $no_restore; then
    printp 'Restoring configurations...';
    for prop in auto_shut auto_switch up_threshold down_threshold shut_threshold; do
        set_prop $prop $(get_prop $prop $old_conf);
    done;
fi;
touch $mod_dir/auto_mount $main_mod_dir/update;
cp -f $mod_dir/module.prop $main_mod_dir/;
printp 'Setting permissions...';
set_perms $mod_dir 0 0644; set_perms $sys_dir/* 2000 0755;
umount $merge_root; losetup -d $loop_device;
rm -rf $tmp_dir;
printp Done; echo -e '\n';
exit 0;
