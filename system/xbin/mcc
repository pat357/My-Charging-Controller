#!/system/bin/sh
# MC's Charging Controller
# mcc Main ( 201804061 )
# MCMotherEffin' @ XDA Developers

# Copyright (c) 2018 Jaymin " MCMotherEffin' " Suthar. All rights reserved.

# This file is a part of the project "MC's Charging Controller ( mcc )".

# I MCMotherEffin', hereby declare that mcc is originally distributed from
## me under the terms of the GNU GPL v3 and you are allowed to use, modify
## or re-distribute the work done for mcc under v3 or any later version of
## GNU GPL as published by the Free Software Foundation provided that this
## declaration and the above copyright notice is included.

# mcc was entirely written to help people extend their device's battery by
## controlling charging, without any kind of WARRANTY, and I can't be held
## responsible for any damage, or just anything bad happened.

# Finally, you should obtain a copy of the GNU GPL v3 from <http://gnu.org/licenses/>.

# Some info about this file.

# This file is the Main script which handles all user operations and does
## contain all the core code of mcc. It firstly will do some stuff for su
## handling, which might resullt in maximux three processes. It will then
## test the environment, which must already be set up by the service. And
## then, after a little logs re-direction, it will handle given arguments
## which includes the daemon mode. All of them will be handled mostly via
## functions defined below, any of which could not be detailed here or it
## will become a documentary project rather than a coding project!!! Last
## thing is that if [ -e / -d ] [ TIME ] is ran, then max procs are four.

if ! id | grep '^uid=0' >/dev/null; then
    su -c mcc "$@"; exit $?;
elif [ ! $no_file_logs ]; then
    if [ ! $no_err_logs ]; then
        no_err_logs=true mcc "$@" 2>/cache/mcc_err.log; exit $?;
    else
        set -x 2>/cache/mcc_env.log; echo ' ';
    fi;
fi;
mod_dir=/it_is_nothing;
if [ ! -d "$mod_dir" ]; then
    if ! mod_dir=$(find /sbin/.core/img /magisk -type d -maxdepth 1 -name mcc); then
        echo -e "- Failed to detect Magisk mount point, aborting...\n"; exit 1;
    fi;
fi;
config=$mod_dir/mcc.conf;
cache_dir=$mod_dir/cache;
lock_file=$cache_dir/lock_d;
ver_log=$cache_dir/verbose.log;
uevent_cache=$cache_dir/uevent_cache.tmp;
export PATH=$mod_dir/busybox:$PATH;
if (! busybox || ! which awk) >/dev/null; then
    echo -e "- Failed to detect BusyBox, aborting...\n"; exit 1;
fi;

abort() { printp "$1, aborting..." >&2; printp "$1, aborting..."; exit 1; }

exit_help() { head -n 110 $mod_dir/docs/README.md; exit 1; }

printp() { echo -e "- $1\n"; }

get_prop() {
    if [[ ! -z $2 ]]; then prop_file=$2; else prop_file=$config; fi;
    sed -n "s/^$1=//p" $prop_file;
}

set_prop() { sed -i "s|^$1=.*|$1=$2|g" $config; }

get_cpid() {
    for pid in $(ps | grep -v ' grep ' | grep " $1$" | awk '{ print $1 }'); do
        if [[ $(grep '^PPid: ' /proc/$pid/status | awk '{ print $2 }') -eq $$ ]]; then
            echo $pid; break;
        else
            unset pid;
        fi;
    done;
}

is_charging() { grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $(uevent_f); }

is_runningd() {
    ps | grep -v ' grep ' | grep ' root ' | grep ' {mcc} ' | grep -q ' --launch-daemon$';
}

are_refs_set() {
    test $(uevent_f) != dummy_Events && test $(get_prop switch_1 | awk '{ print $1 }') != dummy_Switch;
}

test_bound() {
    if [[ $1 -le 0 || $1 -ge 100 ]]; then
        abort 'A threshold must be in the range 0 - 100';
    fi;
}

test_level() {
    if ! echo $1 | grep -Eq '^[0-9]+$'; then
        abort 'A threshold must be a number';
    else
        test_bound $1;
    fi;
}

test_diff() {
    if [[ ! $1 -ge $(($2 + 5)) && ! $force ]]; then
        abort 'Thresholds must at least be 5 levels far';
    fi;
}

test_switch() { if eval $test; then switch_ $turn_1; fi; }

test_refs() {
    if ! are_refs_set; then
        printp 'Attention :- No references set';
        set_ctrl_refs;
    fi;
}

test_daemon() {
    if ! is_runningd; then
        printp 'mcc daemon is not running, launching it...';
        (no_file_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1 &);
        printp 'It should be running now';
    else
        printp 'mcc daemon is already running';
    fi;
}

test_boundaries() {
    if [[ ! -z $2 ]]; then
        if [[ $1 -lt 15 || $2 -lt 15 || $1 -gt 85 || $2 -gt 85 ]]; then
            boundary_err=true;
        fi;
    else
        if [[ $1 -lt 20 || $1 -gt 85 ]]; then boundary_err=true; fi;
        if [[ $1 -lt 26 ]]; then
            if [[ $1 -lt 20 ]]; then
                if [[ $1 -lt 6 ]]; then
                    if [[ $1 -eq 1 ]]; then u=2; d=1; else d=1; fi;
                else
                    d=$(($1 - 5));
                fi;
            else
                d=15;
            fi;
        else
            d=$(($1 - 10));
        fi;
    fi;
    if [[ ! $boundary_err || $force ]]; then
        if [[ -z $u ]]; then u=$1; fi; set_prop up_threshold $u;
        if [[ -z $d ]]; then d=$2; fi; set_prop down_threshold $d;
        printp 'New values saved';
    else
        abort 'Threshold must be in the range 15 - 85';
    fi;
}

reset_stats() {
    printp 'Resetting battery statistics...';
    dumpsys batterystats --reset >/dev/null 2>&1;
    if [[ $1 == rm ]]; then rm -f /data/system/batterystats.bin; fi;
    printp Done;
}

charge_init() {
    touch $lock_file;
    if [[ $turn_1 == ON ]]; then
        if is_charging; then switch_ OFF; fi;
    fi;
    test_switch;
}

charge_free() { rm -f $lock_file; switch_ $turn_2; }

charge_loop() { while eval $1; do test_switch; sleep 1; done; charge_free; }

write_switch() {
    value=$(get_prop switch_$i | awk "{ print \$$1 }");
    if [[ $(cat $switch) != $value ]]; then
        echo $value >$switch; written=true;
    fi;
}

switch_() {
    for i in 1 2; do
        switch=$(get_prop switch_$i | awk '{ print $1 }');
        if [[ $switch != dummy_Switch ]]; then
            case $1 in
                ON ) write_switch 2; ;;
                OFF) write_switch 3; ;;
            esac;
        else
            break;
        fi;
    done;
    if [[ $written ]]; then reset_stats >/dev/null; unset written; fi;
}

toggle() {
    if $($1); then value=false; status=OFF; else value=true; status=ON; fi;
    printp "Toggling $2 $status...";
    set_prop $1 $value;
    printp Done;
}

uevent_f() { get_prop uevent; }

auto_shut() { get_prop auto_shut; }

auto_switch() { get_prop auto_switch; }

daemon_mode() { get_prop daemon_mode; }

up_threshold() { get_prop up_threshold; }

down_threshold() { get_prop down_threshold; }

shut_threshold() { get_prop shut_threshold; }

batt_level() { get_prop POWER_SUPPLY_CAPACITY $(uevent_f); }

set_ctrl_refs() {
    for i in 1 2; do set_prop switch_$i dummy_Switch; done;
    printp 'Re-configuring sysfs references ( requires the battery be charging )...';
    sleep 3;
    find /sys/devices /sys/module -type f -name uevent >$uevent_cache;
    i=1;
    while read uevent; do
        if grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*$' $uevent && grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $uevent; then
            set_prop uevent $uevent;
            for ref in ${uevent%/*}/*; do
                if [[ -f $ref ]]; then
                    if ls -l $ref | grep -Eq '^[a-z-]+w[a-z-]* '; then
                        case $(cat $ref) in
                            1       ) c_ON=1;        c_OFF=0;        ;;
                            0       ) c_ON=0;        c_OFF=1;        ;;
                            on      ) c_ON=on;       c_OFF=off;      ;;
                            off     ) c_ON=off;      c_OFF=on;       ;;
                            true    ) c_ON=true;     c_OFF=false;    ;;
                            false   ) c_ON=false;    c_OFF=true;     ;;
                            enable  ) c_ON=enable;   c_OFF=disable;  ;;
                            disable ) c_ON=disable;  c_OFF=enable;   ;;
                            enabled ) c_ON=enabled;  c_OFF=disabled; ;;
                            disabled) c_ON=disabled; c_OFF=enabled;  ;;
                            *       ) continue;                      ;;
                        esac;
                        echo $c_OFF >$ref; sleep 1;
                        if ! is_charging; then
                            echo $c_ON >$ref; sleep 1;
                            if is_charging; then
                                set_prop switch_$i "$ref $c_ON $c_OFF"; ((i += 1));
                                if [[ $i -eq 3 ]]; then break 2; fi;
                            fi;
                        fi;
                        echo $c_ON >$ref;
                    else
                        continue;
                    fi;
                fi;
            done;
            if [[ $i -gt 1 ]]; then break; fi;
        fi;
    done <$uevent_cache;
    if [[ $i -eq 1 ]]; then
        set_prop uevent dummy_Events;
        if $(daemon_mode); then set_prop daemon_mode false; fi;
        abort 'Failed to re-configure them';
    else
        printp Done;
    fi;
}

charge() {
    case $1 in
        enable ) turn_1=ON;  turn_2=OFF; text=enabled;  test='! is_charging'; ;;
        disable) turn_1=OFF; turn_2=ON;  text=disabled; test='is_charging';   ;;
    esac;
    if [[ ! -z $2 ]]; then
        if echo $2 | grep -Eq '^[0-9]+%$'; then
            level=$(echo $2 | tr -d %);
            test_bound $level;
            charge_init;
            printp "Charging will be $text until $2...";
            charge_loop '[[ ! $(batt_level) -eq $level ]]';
        elif echo $2 | grep -Eq '^[0-9]+[smh]$'; then
            charge_init;
            printp "Charging will be $text for $2...";
            setsid sleep $2;
            sleep_pid=$(get_cpid "sleep $2");
            charge_loop 'ps | grep -q "^$sleep_pid "';
        else
            abort 'The argument must be in mcc recognized format';
        fi;
    else
        charge_init;
        printp "Charging has been $text";
        charge_free;
    fi;
}

if [[ ! $no_file_logs ]]; then
    echo 'mcc versionCode = 201804061' >$ver_log;
    echo -e "magisk versionCode = $(magisk -V)\n" >>$ver_log;
    echo -e "device properties\n" >>$ver_log;
    for prop in ro.product.brand ro.product.model ro.build.product ro.product.device ro.build.description ro.build.fingerprint ro.product.cpu.abi ro.product.cpu.abilist; do
        echo "$prop :- $(getprop $prop)" >>$ver_log;
    done;
    echo ' ' >>$ver_log;
    set +x; set -x 2>>$ver_log;
fi;
case $1 in -f|--force) force=true; shift; ;; esac;
case $1 in
    -i|--info)
        test_refs;
        printp 'Battery status';
        echo "-- battery level :- $(batt_level)";
        echo "-- battery health :- $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))";
        if is_charging; then status=Charging; else status='Not charging'; fi;
        echo -e "-- charging status :- $status\n";
        printp 'Current settings';
        echo "-- up threshold :- $(up_threshold)";
        echo "-- down threshold :- $(down_threshold)";
        echo -e "-- shut threshold :- $(shut_threshold)\n";
        if $(auto_switch); then status=ON; else status=OFF; fi;
        echo "-- automatic switching :- $status";
        if $(auto_shut); then status=ON; else status=OFF; fi;
        echo "-- automatic power-off :- $status";
        if $(daemon_mode); then status=ON; else status=OFF; fi;
        echo -e "-- background daemon mode :- $status\n";
        if is_runningd; then status=Running; else status='Not running'; fi;
        echo -e "-- daemon ( bg activity ) status :- $status\n";
    ;;
    -h|--help) exit_help; ;;
    -rc|--reconf) set_ctrl_refs; ;;
    -r|--rm-stats) reset_stats rm; ;;
    --donate)
        printp 'Heyyo!!! Thanks'; sleep 2;
        am start https://paypal.me/JayminSuthar >/dev/null;
    ;;
    -tp|--auto-shut)
        if ! $(auto_shut) && $(daemon_mode); then test_refs; fi;
        toggle auto_shut 'auto shut';
    ;;
    -ts|--auto-switch)
        if ! $(auto_switch) && $(daemon_mode); then test_refs; fi;
        toggle auto_switch 'auto switch';
    ;;
    -dm|--daemon-mode)
        if ! $(daemon_mode); then
            if ! $(auto_shut) && ! $(auto_switch); then
                abort 'Daemon mode requires at lease one of auto switch or auto shut';
            else
                test_refs;
            fi;
        fi;
        toggle daemon_mode 'daemon mode';
    ;;
    -e|--enable) test_refs; charge enable $2; ;;
    -d|--disable) test_refs; charge disable $2; ;;
    -rd|--re-daemon)
        if $(daemon_mode); then
            if ! $(auto_shut) && ! $(auto_switch); then
                abort 'mcc daemon requires at least one of auto switch or auto shut';
            else
                test_refs; test_daemon;
            fi;
        else
            abort 'Launching the daemon requires daemon mode';
        fi;
    ;;
    --launch-daemon)
        while $(auto_shut) || $(auto_switch) && $(daemon_mode); do
            while ! are_refs_set || test -f $lock_file; do sleep 1; done;
            if $(auto_shut); then
                if [[ $(batt_level) -le $(shut_threshold) ]]; then
                    if ! is_charging; then setprop sys.powerctl shutdown; fi;
                fi;
            fi;
            if $(auto_switch); then
                if [[ $(batt_level) -le $(down_threshold) ]]; then
                    if is_charging; then
                        if [[ $no_ckcurrent || $(get_prop POWER_SUPPLY_CURRENT_NOW $(uevent_f)) -le 0 ]]; then
                            no_ckcurrent=true;
                        else
                            switch_ OFF;
                        fi;
                    fi;
                    if ! is_charging; then switch_ ON; fi;
                elif [[ $(batt_level) -ge $(up_threshold) ]]; then
                    if is_charging; then switch_ OFF; unset no_ckcurrent; fi;
                fi;
            fi;
            sleep 1;
        done;
    ;;
    -df|--default)
        set_prop shut_threshold 20;
        set_prop up_threshold 80; set_prop down_threshold 70;
        printp 'All the thresholds are reverted to the defaults';
    ;;
    -p|--shut)
        if [[ ! -z $2 ]]; then
            if echo $2 | grep -Eq '^[0-9]+$'; then
                if [[ $2 -gt 20 || $2 -lt 5 ]]; then
                    if [[ ! $force ]]; then
                        abort 'Threshold must be in the range 5 - 20';
                    else
                        test_bound $2;
                    fi;
                fi;
                set_prop shut_threshold $2;
                printp 'New value saved';
            else
                abort 'A threshold must be a number';
            fi;
        else
            abort 'A threshold must be given';
        fi;
    ;;
    -s|--switch)
        if [[ ! -z $3 ]]; then
            test_level $3; test_level $2;
            if [[ $3 -gt $2 ]]; then
                test_diff $3 $2; test_boundaries $3 $2;
            elif [[ $2 -gt $3 ]]; then
                test_diff $2 $3; test_boundaries $2 $3;
            else
                abort 'Thresholds must not be same';
            fi;
        elif [[ ! -z $2 ]]; then
            test_level $2; test_boundaries $2;
        else
            abort 'Threshold(s) must be given';
        fi;
    ;;
    *)
        printp 'Invalid argument(s)'; sleep 2;
        exit_help;
    ;;
esac;
exit 0;
