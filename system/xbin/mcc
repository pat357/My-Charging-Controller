#!/system/bin/sh
# MC's Charging Controller
# mcc Main ( 201804111 )
# MCMotherEffin' @ XDA Developers

# Copyright (c) 2018 Jaymin " MCMotherEffin' " Suthar. All rights reserved.

# This file is a part of the project "MC's Charging Controller ( mcc )".

# I MCMotherEffin', hereby declare that mcc is originally distributed from
## me under the terms of the GNU GPL v3 and you are allowed to use, modify
## or re-distribute the work done for mcc under v3 or any later version of
## GNU GPL as published by the Free Software Foundation provided that this
## declaration and the above copyright notice is included.

# mcc was entirely written for helping people extend their batteries' life
## by controlling charging, without any kind of WARRANTY, and I can not be
## held responsible for any damage, or just anything bad happened.

# Finally, you should have received a copy of the GPL v3 with mcc, if not,
## see <http://gnu.org/licenses/>.

if ! id | grep '^uid=0' >/dev/null; then
    su -c mcc "$@"; exit $?;
elif [ ! $no_file_logs ]; then
    if [ ! $no_err_logs ]; then
        no_err_logs=true mcc "$@" 2>/cache/mcc_err.log; exit $?;
    fi;
    set -x 2>/cache/mcc_env.log; echo ' ';
fi;
mod_dir=/it_is_nothing;
if [ ! -d "$mod_dir" ]; then
    mod_dir=$(find /sbin/.core/img /magisk -type d -maxdepth 1 -name mcc);
    if [ ! -d "$mod_dir" ]; then
        echo -e "mcc: error: Failed to detect MOUNTPOINT\n"; exit 1;
    fi;
fi;
config=$mod_dir/mcc.conf;
cache_dir=$mod_dir/cache;
lock_file=$cache_dir/lock;
ver_log=$cache_dir/verbose.log;
uevent_cache=$cache_dir/uevent_cache.tmp;
export PATH=$mod_dir/busybox:$PATH;
if (! busybox | grep 'topjohnwu ' || ! which awk) >/dev/null; then
    echo -e "mcc: error: Failed to set BusyBox up\n"; exit 1;
fi;

abort() { echo -e "mcc: error: $1" >&2; echo -e "mcc: error: $1\n"; exit 1; }

exit_help() { head -114 $mod_dir/docs/README.md; exit 1; }

printp() { echo -e "mcc: info: $1\n"; }

get_prop() { sed -n "s/^$1=//p" $2 $config; }

set_prop() { sed -i "s|^$1=.*|$1=$2|g" $config; }

get_cpid() {
    for pid in $(ps | grep -v ' grep ' | grep " $1$" | awk '{ print $1 }'); do
        if [[ $(grep '^PPid: ' /proc/$pid/status | awk '{ print $2 }') -eq $$ ]]; then
            echo $pid; break;
        fi;
        unset pid;
    done;
}

is_charging() { grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $(uevent_f); }

is_runningd() {
    ps | grep -v ' grep ' | grep ' root ' | grep ' {mcc} ' | grep ' --launch-daemon$' | grep -vq "^ *$$ ";
}

are_refs_set() {
    test $(uevent_f) != dummy_Events && test $(get_prop switch_1 | awk '{ print $1 }') != dummy_Switch;
}

test_bound() {
    if [[ $1 -le 0 || $1 -ge 100 ]]; then
        abort 'A threshold must belong to 0 - 100';
    fi;
}

test_level() {
    if ! echo $1 | grep -Eq '^[0-9]+$'; then
        abort 'A threshold must be a number';
    fi;
    test_bound $1;
}

test_diff() {
    if [[ ! $1 -ge $(($2 + 5)) && ! $enforce ]]; then
        abort 'Thresholds must keep 5 levels difference';
    fi;
}

test_switch() { if eval $test; then switch_ $turn_1; fi; }

test_refs() {
    if ! are_refs_set; then
        echo -e 'mcc: warning: No references set\n';
        set_ctrl_refs;
    fi;
}

test_daemon() {
    if ! is_runningd; then
        printp 'mcc daemon is not running, launching it...';
        ( (no_file_logs=true mcc --launch-daemon </dev/null >/dev/null 2>&1) &);
        if ! is_runningd; then abort 'Failed to launch the daemon'; fi;
        printp "It's running now";
    else
        printp 'mcc daemon is already running';
    fi;
}

test_boundaries() {
    if [[ ( (! -z $2 && ($1 -lt 15 || $2 -lt 15 || $1 -gt 85 || $2 -gt 85)) || ($1 -lt 20 || $1 -gt 85)) && ! $enforce ]]; then
        abort 'Threshold(s) must belong to 15 - 85';
    fi;
    if [[ $1 -ge 25 ]]; then
        d=$(($1 - 10));
    elif [[ $1 -ge 20 ]]; then
        d=15;
    elif [[ $1 -ge 6 ]]; then
        d=$(($1 - 5));
    elif [[ $1 -eq 1 ]]; then
        u=2; d=1;
    else
        d=1;
    fi;
    if [[ -z $u ]]; then u=$1; fi; set_prop up_threshold $u;
    if [[ -z $d ]]; then d=$2; fi; set_prop down_threshold $d;
    printp 'New values saved';
}

charge_init() {
    touch $lock_file;
    if [[ $turn_1 == ON ]]; then
        if is_charging; then switch_ OFF; fi;
    fi;
    test_switch;
}

charge_free() { rm -f $lock_file; switch_ $turn_2; }

charge_loop() { while eval $1; do test_switch; sleep 1; done; }

write_switch() {
    value=$(get_prop switch_$i | awk "{ print \$$1 }");
    if [[ $(cat $switch) != $value ]]; then echo $value >$switch; fi;
}

switch_() {
    for i in 1 2; do
        switch=$(get_prop switch_$i | awk '{ print $1 }');
        if [[ $switch != dummy_Switch ]]; then
            case $1 in ON) write_switch 2; ;; OFF) write_switch 3; ;; esac;
        fi;
    done;
}

toggle() {
    value=true; status=ON; if $($1); then value=false; status=OFF; fi;
    printp "Toggling $2 $status...";
    set_prop $1 $value;
    printp Done;
}

uevent_f() { get_prop uevent; }

auto_shut() { get_prop auto_shut; }

auto_switch() { get_prop auto_switch; }

daemon_mode() { get_prop daemon_mode; }

up_threshold() { get_prop up_threshold; }

down_threshold() { get_prop down_threshold; }

shut_threshold() { get_prop shut_threshold; }

batt_level() { get_prop POWER_SUPPLY_CAPACITY $(uevent_f); }

set_ctrl_refs() {
    for i in 1 2; do set_prop switch_$i dummy_Switch; done;
    printp 'Resetting mcc internals ( requires charging ON )...';
    sleep 3;
    find /sys/devices /sys/module -type f -name uevent >$uevent_cache;
    i=1;
    while read uevent; do
        if grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*$' $uevent && grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $uevent; then
            set_prop uevent $uevent;
            while read eff_uevent; do
                if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*$' $eff_uevent && grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $eff_uevent) || grep -q '^DRIVER=.*[Cc]harger.*$' $eff_uevent; then
                    for ref in ${eff_uevent%/*}/*; do
                        if [[ -f $ref ]]; then
                            if ls -l $ref | grep -Eq '^[a-z-]+w[a-z-]* '; then
                                case $(cat $ref) in
                                    1       ) c_ON=1;        c_OFF=0;        ;;
                                    0       ) c_ON=0;        c_OFF=1;        ;;
                                    on      ) c_ON=on;       c_OFF=off;      ;;
                                    off     ) c_ON=off;      c_OFF=on;       ;;
                                    true    ) c_ON=true;     c_OFF=false;    ;;
                                    false   ) c_ON=false;    c_OFF=true;     ;;
                                    enable  ) c_ON=enable;   c_OFF=disable;  ;;
                                    disable ) c_ON=disable;  c_OFF=enable;   ;;
                                    enabled ) c_ON=enabled;  c_OFF=disabled; ;;
                                    disabled) c_ON=disabled; c_OFF=enabled;  ;;
                                    *       ) continue;                      ;;
                                esac;
                                echo $c_OFF >$ref; sleep 1;
                                if ! is_charging; then
                                    echo $c_ON >$ref; sleep 1;
                                    if is_charging; then
                                        set_prop switch_$i "$ref $c_ON $c_OFF";
                                        ((i += 1));
                                        if [[ $i -eq 3 ]]; then break 3; fi;
                                    fi;
                                fi;
                                echo $c_ON >$ref;
                            fi;
                        fi;
                    done;
                    if [[ $i -gt 1 ]]; then break 2; fi;
                fi;
            done <$uevent_cache;
        fi;
    done <$uevent_cache;
    if [[ $i -eq 1 ]]; then
        set_prop uevent dummy_Events;
        if $(daemon_mode); then set_prop daemon_mode false; fi;
        abort 'Failed to reset them';
    fi;
    printp Done;
}

charge() {
    case $1 in
        enable ) turn_1=ON;  turn_2=OFF; text=enabled;  test='! is_charging'; ;;
        disable) turn_1=OFF; turn_2=ON;  text=disabled; test='is_charging';   ;;
    esac;
    if [[ ! -z $2 ]]; then
        if echo $2 | grep -Eq '^[0-9]+%$'; then
            level=$(echo $2 | tr -d %);
            test_bound $level;
            charge_init;
            printp "Keeping charging $text until $2...";
            charge_loop '[[ ! $(batt_level) -eq $level ]]';
        elif echo $2 | grep -Eq '^[0-9]+[smh]$'; then
            charge_init;
            printp "Keeping charging $text for $2...";
            setsid sleep $2;
            sleep_pid=$(get_cpid "sleep $2");
            charge_loop 'ps | grep -q "^ *$sleep_pid "';
        else
            abort 'Invalid argument format';
        fi;
        charge_free;
    else
        charge_init;
        printp "Charging has been $text";
        rm -f $lock_file;
    fi;
}

if [[ ! $no_file_logs ]]; then
    set +x;
    echo -e 'mcc: debug: build 201804111 logs begin\n' >$ver_log;
    set -x 2>>$ver_log;
fi;
case $1 in -f|--force) enforce=true; shift; ;; esac;
case $1 in
    -i|--info)
        test_refs;
        printp 'Battery status';
        echo "-- battery level: $(batt_level)";
        echo "-- battery health: $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))";
        if is_charging; then status=Charging; else status='Not charging'; fi;
        echo -e "-- charging status: $status\n";
        printp 'Current settings';
        echo "-- up threshold: $(up_threshold)";
        echo "-- down threshold: $(down_threshold)";
        echo -e "-- shut threshold: $(shut_threshold)\n";
        if $(auto_switch); then status=ON; else status=OFF; fi;
        echo "-- automatic switching: $status";
        if $(auto_shut); then status=ON; else status=OFF; fi;
        echo "-- automatic power-off: $status";
        if $(daemon_mode); then status=ON; else status=OFF; fi;
        echo -e "-- background daemon mode: $status\n";
        if is_runningd; then status=Running; else status='Not running'; fi;
        echo -e "-- daemon status: $status\n";
    ;;
    -h|--help   ) exit_help;      ;;
    -rc|--reconf) set_ctrl_refs;  ;;
    -r|--rm-stats)
        printp 'Resetting battery statistics...';
        dumpsys batterystats --reset >/dev/null 2>&1;
        rm -f /data/system/batterystats.bin;
        printp Done;
    ;;
    -tp|--auto-shut)
        if ! $(auto_shut) && $(daemon_mode); then test_refs; fi;
        toggle auto_shut 'auto shut';
    ;;
    -ts|--auto-switch)
        if ! $(auto_switch) && $(daemon_mode); then test_refs; fi;
        toggle auto_switch 'auto switch';
    ;;
    -dm|--daemon-mode)
        if ! $(daemon_mode); then
            if ! $(auto_shut) && ! $(auto_switch); then
                abort 'Neither auto switch or auto shut is ON';
            fi;
            test_refs;
        fi;
        toggle daemon_mode 'daemon mode';
    ;;
    -e|--enable ) test_refs; charge enable $2;  ;;
    -d|--disable) test_refs; charge disable $2; ;;
    -rd|--re-daemon)
        if ! $(daemon_mode); then
            abort 'Daemon mode is not ON';
        elif ! $(auto_shut) && ! $(auto_switch); then
            abort 'Neither auto switch or auto shut is ON';
        fi;
        test_refs; test_daemon;
    ;;
    --launch-daemon)
        if is_runningd; then abort 'mcc daemon is already running'; fi;
        while $(daemon_mode) && ($(auto_shut) || $(auto_switch)); do
            if are_refs_set && test ! -f $lock_file; then
                if $(auto_shut); then
                    if [[ $(batt_level) -le $(shut_threshold) ]]; then
                        if ! is_charging; then
                            setprop sys.powerctl shutdown;
                        fi;
                    fi;
                fi;
                if $(auto_switch); then
                    if [[ $(batt_level) -le $(down_threshold) ]]; then
                        if is_charging; then
                            if [[ $no_ckcurrent || $(get_prop POWER_SUPPLY_CURRENT_NOW $(uevent_f)) -le 0 ]]; then
                                no_ckcurrent=true;
                            else
                                switch_ OFF;
                            fi;
                        fi;
                        if ! is_charging; then switch_ ON; fi;
                    elif [[ $(batt_level) -ge $(up_threshold) ]]; then
                        if is_charging; then
                            switch_ OFF; unset no_ckcurrent;
                        fi;
                    fi;
                fi;
            fi;
            sleep 1;
        done;
    ;;
    -df|--default)
        set_prop shut_threshold 20;
        set_prop up_threshold 80; set_prop down_threshold 70;
        printp 'All thresholds are reverted to their defaults';
    ;;
    -p|--shut)
        if [[ -z $2 ]]; then
            abort 'A threshold must be given';
        elif ! echo $2 | grep -Eq '^[0-9]+$'; then
            abort 'A threshold must be a number';
        elif [[ ($2 -gt 20 || $2 -lt 5) && ! $enforce ]]; then
            abort 'Threshold must belong to 5 - 20';
        fi;
        test_bound $2;
        set_prop shut_threshold $2;
        printp 'New value saved';
    ;;
    -s|--switch)
        if [[ ! -z $3 ]]; then
            test_level $3; test_level $2;
            if [[ $3 -gt $2 ]]; then
                test_diff $3 $2; test_boundaries $3 $2;
            elif [[ $2 -gt $3 ]]; then
                test_diff $2 $3; test_boundaries $2 $3;
            else
                abort 'Thresholds must be different';
            fi;
        elif [[ ! -z $2 ]]; then
            test_level $2; test_boundaries $2;
        else
            abort 'Threshold(s) must be given';
        fi;
    ;;
    *)
        printp 'mcc called with invalid argument(s)'; sleep 2;
        exit_help;
    ;;
esac;
exit 0;
